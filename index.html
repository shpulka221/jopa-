<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Puzzle ‚Äî Adventure & Classic</title>
  <style>
    :root{
      --bg1:#0b2a7b;
      --bg2:#0a1b4d;
      --panel:#0b2a7b;
      --panel2:#0a2366;
      --gridBorder:#2aa1ff;
      --cellA:rgba(255,255,255,.06);
      --cellB:rgba(255,255,255,.03);
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --soft: 0 10px 20px rgba(0,0,0,.25);
      --text:#e9f3ff;
      --muted:rgba(233,243,255,.72);
      --good:#33e28a;
      --warn:#ffcc4d;
      --bad:#ff4d73;
      --btn:#2fe084;
      --btn2:#1ecf76;
    }

    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%; margin:0; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 50% -10%, #1f63ff33, transparent 60%),
        radial-gradient(900px 600px at 20% 20%, #53c1ff22, transparent 55%),
        radial-gradient(900px 600px at 85% 35%, #a855ff1f, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
      user-select:none;
    }

    /* subtle pixel specks */
    body:before{
      content:"";
      position:fixed; inset:0;
      background-image:
        radial-gradient(circle at 12% 22%, rgba(255,255,255,.06) 0 2px, transparent 3px),
        radial-gradient(circle at 40% 14%, rgba(255,255,255,.05) 0 2px, transparent 3px),
        radial-gradient(circle at 74% 18%, rgba(255,255,255,.05) 0 2px, transparent 3px),
        radial-gradient(circle at 22% 60%, rgba(255,255,255,.04) 0 2px, transparent 3px),
        radial-gradient(circle at 62% 70%, rgba(255,255,255,.04) 0 2px, transparent 3px),
        radial-gradient(circle at 86% 62%, rgba(255,255,255,.04) 0 2px, transparent 3px);
      opacity:.75;
      pointer-events:none;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:14px;
      padding:14px;
    }

    .topbar{
      width:min(520px, 96vw);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      padding:10px 14px;
      border-radius:18px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--soft);
      backdrop-filter: blur(10px);
    }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background: conic-gradient(from 200deg, #ff4d73, #ffcc4d, #33e28a, #2aa1ff, #a855ff, #ff4d73);
      box-shadow: 0 10px 18px rgba(0,0,0,.25);
      position:relative;
    }
    .logo:after{
      content:"";
      position:absolute; inset:6px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,.35), rgba(255,255,255,.05));
      mix-blend-mode: overlay;
    }
    .brand .t1{font-weight:900; letter-spacing:.4px; font-size:14px; line-height:1.05;}
    .brand .t2{font-size:11px; color:var(--muted); margin-top:1px;}

    .modeTabs{
      display:flex; gap:10px; align-items:center;
    }
    .tab{
      border:none;
      cursor:pointer;
      color:var(--text);
      font-weight:800;
      letter-spacing:.3px;
      padding:10px 14px;
      border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      box-shadow: var(--soft);
      transition: transform .12s ease, filter .12s ease;
    }
    .tab:active{transform: translateY(1px) scale(.99);}
    .tab.active{
      background: linear-gradient(180deg, rgba(47,224,132,.95), rgba(30,207,118,.9));
      color:#08321e;
      filter: saturate(1.1);
    }

    .hud{
      display:flex; gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex:1;
    }
    .pill{
      display:flex; flex-direction:column;
      gap:1px;
      padding:10px 12px;
      border-radius:16px;
      min-width:110px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--soft);
      backdrop-filter: blur(10px);
    }
    .pill .k{font-size:11px; color:var(--muted); font-weight:700;}
    .pill .v{font-size:18px; font-weight:900; letter-spacing:.4px; display:flex; align-items:center; gap:6px;}
    .crown{
      display:inline-grid; place-items:center;
      width:20px; height:20px; border-radius:8px;
      background: linear-gradient(180deg, rgba(255,204,77,.95), rgba(255,166,0,.85));
      color:#3b2500;
      box-shadow: 0 10px 18px rgba(0,0,0,.20);
      font-size:13px;
    }

    .stage{
      width:min(520px, 96vw);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:14px;
    }

    .boardWrap{
      position:relative;
      width: min(420px, 92vw);
      aspect-ratio: 1 / 1;
      border-radius:22px;
      padding:10px;
      background: linear-gradient(180deg, rgba(42,161,255,.28), rgba(42,161,255,.10));
      box-shadow: var(--shadow);
    }
    .board{
      width:100%;
      height:100%;
      border-radius:18px;
      background:
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.18)),
        radial-gradient(140% 120% at 50% 0%, rgba(255,255,255,.05), transparent 60%);
      border: 3px solid rgba(42,161,255,.65);
      overflow:hidden;
      display:grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 1px;
      padding: 8px;
    }
    .cell{
      border-radius: 6px;
      background: var(--cellB);
      position:relative;
      overflow:hidden;
      transform: translateZ(0);
    }
    .cell:nth-child(odd){ background: var(--cellA); }

    .cell.target:before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(16px 14px at 30% 25%, rgba(255,255,255,.12), transparent 60%),
        radial-gradient(18px 16px at 70% 70%, rgba(255,255,255,.10), transparent 65%),
        linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02));
      opacity:.75;
      mix-blend-mode: screen;
    }
    .cell.target{
      outline: 1px dashed rgba(255,255,255,.20);
      background: rgba(255,255,255,.08);
    }

    .cell.filled{
      background: var(--fill, #ff4d73);
      box-shadow: inset 0 -10px 18px rgba(0,0,0,.18), inset 0 10px 18px rgba(255,255,255,.12);
      animation: popIn .16s ease-out;
    }
    .cell.filled:after{
      content:"";
      position:absolute; inset:-30%;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.55), transparent 40%),
                  radial-gradient(circle at 70% 70%, rgba(255,255,255,.28), transparent 45%);
      opacity:.22;
      transform: rotate(25deg);
      pointer-events:none;
    }

    @keyframes popIn{
      0%{ transform: scale(.85); filter: brightness(.9); }
      100%{ transform: scale(1); filter: brightness(1); }
    }

    .cell.previewOk{
      outline: 2px solid rgba(51,226,138,.9);
      filter: brightness(1.05);
    }
    .cell.previewBad{
      outline: 2px solid rgba(255,77,115,.9);
      filter: brightness(.92);
    }

    .clearFlash{
      position:absolute; inset:8px;
      border-radius:18px;
      pointer-events:none;
      background:
        linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      transform: translateX(-120%);
      opacity:0;
    }
    .clearFlash.run{
      animation: sweep .42s ease-out;
    }
    @keyframes sweep{
      0%{ transform: translateX(-120%); opacity:0; }
      20%{ opacity:1; }
      100%{ transform: translateX(120%); opacity:0; }
    }

    .bottom{
      width:min(520px, 96vw);
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }

    .pieces{
      width:min(520px, 96vw);
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      border-radius:22px;
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .pieceSlot{
      flex:1;
      min-width:0;
      display:grid;
      place-items:center;
      border-radius:18px;
      background: rgba(0,0,0,.12);
      padding:10px;
      position:relative;
      overflow:hidden;
    }
    .pieceSlot.empty{
      opacity:.35;
    }

    .piece{
      width:100%;
      max-width:140px;
      aspect-ratio: 1 / 1;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap:4px;
      touch-action:none;
      cursor:grab;
      filter: drop-shadow(0 12px 14px rgba(0,0,0,.25));
      transition: transform .12s ease;
    }
    .piece:active{ cursor:grabbing; }
    .pCell{
      border-radius:8px;
      background: transparent;
      position:relative;
    }
    .pCell.on{
      background: var(--pcolor);
      box-shadow: inset 0 -10px 18px rgba(0,0,0,.16), inset 0 10px 18px rgba(255,255,255,.14);
    }
    .pCell.on:after{
      content:"";
      position:absolute; inset:-35%;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.6), transparent 40%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.25), transparent 50%);
      opacity:.22;
      transform: rotate(25deg);
      pointer-events:none;
    }

    .controls{
      width:min(520px, 96vw);
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
    }
    .btn{
      flex:1;
      border:none;
      cursor:pointer;
      border-radius:18px;
      padding:12px 14px;
      font-weight:900;
      letter-spacing:.4px;
      background: linear-gradient(180deg, rgba(47,224,132,.98), rgba(30,207,118,.92));
      color:#08321e;
      box-shadow: var(--shadow);
      transition: transform .12s ease, filter .12s ease;
    }
    .btn.secondary{
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      color:var(--text);
      box-shadow: var(--soft);
      flex:.7;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }

    .overlay{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.38);
      backdrop-filter: blur(8px);
      z-index:50;
      padding:16px;
    }
    .overlay.show{ display:grid; }
    .modal{
      width:min(520px, 96vw);
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.07));
      box-shadow: var(--shadow);
      padding:16px;
      position:relative;
      overflow:hidden;
    }
    .modal:before{
      content:"";
      position:absolute; inset:-60%;
      background: radial-gradient(circle at 40% 30%, rgba(255,204,77,.28), transparent 55%),
                  radial-gradient(circle at 70% 70%, rgba(51,226,138,.18), transparent 60%),
                  radial-gradient(circle at 35% 75%, rgba(42,161,255,.20), transparent 60%);
      transform: rotate(12deg);
      pointer-events:none;
    }
    .modal h2{margin:0 0 6px; font-size:18px; letter-spacing:.2px;}
    .modal p{margin:0 0 12px; color:var(--muted); font-weight:650;}
    .modal .row{display:flex; gap:10px;}
    .modal .row .btn{flex:1;}

    .toast{
      position:absolute;
      left:50%; top:12px;
      transform: translateX(-50%);
      padding:10px 14px;
      border-radius:16px;
      background: rgba(0,0,0,.34);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      font-weight:900;
      letter-spacing:.3px;
      opacity:0;
      pointer-events:none;
      z-index:40;
    }
    .toast.show{
      animation: toastPop .9s ease forwards;
    }
    @keyframes toastPop{
      0%{opacity:0; transform: translateX(-50%) translateY(-8px) scale(.98);}
      15%{opacity:1; transform: translateX(-50%) translateY(0) scale(1);}
      75%{opacity:1;}
      100%{opacity:0; transform: translateX(-50%) translateY(-10px) scale(.98);}
    }

    canvas#fx{
      position:fixed; inset:0;
      pointer-events:none;
      z-index:60;
    }

    .dragGhost{
      position:fixed;
      left:0; top:0;
      width: 170px;
      height: 170px;
      transform: translate(-9999px,-9999px);
      z-index:70;
      pointer-events:none;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap:5px;
      filter: drop-shadow(0 16px 18px rgba(0,0,0,.32));
    }
    .dragGhost .pCell{ border-radius:10px; }
    .dragGhost .pCell.on{ box-shadow: inset 0 -12px 20px rgba(0,0,0,.18), inset 0 12px 20px rgba(255,255,255,.14); }
    .dragGhost.hidden{display:none;}

    .tinyHint{
      font-size:11px; color:var(--muted); font-weight:750;
      text-align:center;
      margin-top:-6px;
    }

    @media (max-height: 760px){
      .boardWrap{ width:min(380px, 92vw); }
      .pieces{ padding:10px; }
      .piece{ max-width:120px; }
      .pill{ min-width:96px; }
    }
  </style>
</head>
<body>
  <canvas id="fx"></canvas>

  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="t1">BLOCK PUZZLE</div>
          <div class="t2">Adventure + Classic</div>
        </div>
      </div>

      <div class="modeTabs">
        <button class="tab active" id="tabAdventure">Adventure</button>
        <button class="tab" id="tabClassic">Classic</button>
      </div>

      <div class="hud">
        <div class="pill">
          <div class="k" id="kLeft">LEVEL</div>
          <div class="v" id="vLeft">1</div>
        </div>
        <div class="pill">
          <div class="k">SCORE</div>
          <div class="v" id="score">0</div>
        </div>
        <div class="pill">
          <div class="k">BEST</div>
          <div class="v"><span class="crown">üëë</span><span id="best">0</span></div>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="boardWrap" id="boardWrap">
        <div class="toast" id="toast">–ö–†–ê–°–ê–í–ê!</div>
        <div class="clearFlash" id="clearFlash"></div>
        <div class="board" id="board"></div>
      </div>

      <div class="tinyHint" id="hint">
        Adventure: –∑–∞–∫—Ä–∞—Å—å ‚Äú–∫–∞—Ä—Ç–∏–Ω–∫—É‚Äù (–ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏). Classic: –Ω–∞–±–∏–≤–∞–π —Ä–µ–∫–æ—Ä–¥.
      </div>
    </div>

    <div class="bottom">
      <div class="pieces" id="pieces"></div>

      <div class="controls">
        <button class="btn secondary" id="btnNew">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button class="btn" id="btnShuffle">–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Ñ–∏–≥—É—Ä—ã (x1)</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2 id="modalTitle">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
      <p id="modalText">–•–æ–¥–æ–≤ –Ω–µ—Ç. –•–æ—á–µ—à—å –∑–∞–Ω–æ–≤–æ?</p>
      <div class="row">
        <button class="btn secondary" id="btnClose">–ó–∞–∫—Ä—ã—Ç—å</button>
        <button class="btn" id="btnRestart">–ó–∞–Ω–æ–≤–æ</button>
      </div>
    </div>
  </div>

  <div class="dragGhost hidden" id="ghost"></div>

<script>
(() => {
  // -------------------------
  // Utils
  // -------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b+1));
  const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
  const key = {
    bestClassic: "bb_best_classic_v1",
    bestAdventure: "bb_best_adventure_v1",
    advLevel: "bb_adv_level_v1"
  };

  // -------------------------
  // DOM
  // -------------------------
  const boardEl = document.getElementById("board");
  const piecesEl = document.getElementById("pieces");
  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const vLeftEl = document.getElementById("vLeft");
  const kLeftEl = document.getElementById("kLeft");
  const toastEl = document.getElementById("toast");
  const overlayEl = document.getElementById("overlay");
  const modalTitleEl = document.getElementById("modalTitle");
  const modalTextEl = document.getElementById("modalText");
  const clearFlashEl = document.getElementById("clearFlash");
  const tabAdvEl = document.getElementById("tabAdventure");
  const tabClaEl = document.getElementById("tabClassic");
  const btnNew = document.getElementById("btnNew");
  const btnShuffle = document.getElementById("btnShuffle");
  const btnClose = document.getElementById("btnClose");
  const btnRestart = document.getElementById("btnRestart");
  const hintEl = document.getElementById("hint");
  const ghostEl = document.getElementById("ghost");

  // -------------------------
  // FX Canvas (fireworks + confetti)
  // -------------------------
  const fx = document.getElementById("fx");
  const ctx = fx.getContext("2d");
  let W = 0, H = 0;
  function resizeFX(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * dpr);
    H = Math.floor(innerHeight * dpr);
    fx.width = W; fx.height = H;
    fx.style.width = innerWidth+"px";
    fx.style.height = innerHeight+"px";
    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener("resize", resizeFX);
  resizeFX();

  const particles = [];
  function spawnFirework(x, y, power=1){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cx = x * dpr, cy = y * dpr;
    const count = Math.floor(90 * power);
    const colors = ["#ff4d73","#ffcc4d","#33e28a","#2aa1ff","#a855ff","#00e5ff"];
    for(let i=0;i<count;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(2.0, 7.5) * power * dpr;
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp - rand(0, 1.2*dpr),
        life: rand(40, 70),
        t: 0,
        size: rand(1.6, 3.6) * dpr,
        col: pick(colors),
        grav: 0.10 * dpr,
        drag: 0.985
      });
    }
  }
  function spawnConfetti(power=1){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const count = Math.floor(120 * power);
    const colors = ["#ff4d73","#ffcc4d","#33e28a","#2aa1ff","#a855ff","#ffffff"];
    for(let i=0;i<count;i++){
      particles.push({
        x: rand(0, W), y: rand(-40*dpr, 0),
        vx: rand(-1.5, 1.5)*dpr,
        vy: rand(1.5, 4.0)*dpr,
        life: rand(90, 150),
        t: 0,
        size: rand(2.2, 5.0)*dpr,
        col: pick(colors),
        grav: 0.03*dpr,
        drag: 0.995,
        rect: true,
        rot: rand(0, Math.PI*2),
        vr: rand(-0.2, 0.2)
      });
    }
  }
  function tickFX(){
    ctx.clearRect(0,0,W,H);
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t++;
      p.vx *= p.drag;
      p.vy = (p.vy + p.grav) * p.drag;
      p.x += p.vx;
      p.y += p.vy;
      const a = 1 - (p.t / p.life);
      if(a <= 0){
        particles.splice(i,1);
        continue;
      }
      ctx.globalAlpha = clamp(a, 0, 1);
      ctx.fillStyle = p.col;
      if(p.rect){
        p.rot += p.vr;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.size, -p.size*0.35, p.size*2, p.size*0.7);
        ctx.restore();
      }else{
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
    requestAnimationFrame(tickFX);
  }
  tickFX();

  // -------------------------
  // Game Data
  // -------------------------
  const N = 10;
  const board = Array.from({length:N}, () => Array(N).fill(null)); // null or color
  let mode = "adventure"; // "classic"
  let score = 0;
  let bestClassic = parseInt(localStorage.getItem(key.bestClassic) || "0", 10);
  let bestAdventure = parseInt(localStorage.getItem(key.bestAdventure) || "0", 10);
  let adventureLevel = parseInt(localStorage.getItem(key.advLevel) || "1", 10);
  if(!Number.isFinite(adventureLevel) || adventureLevel < 1) adventureLevel = 1;

  let shuffleLeft = 1;

  // shapes are in 5x5 masks
  const SHAPES = [
    // Singles / lines
    [[1]],
    [[1,1]],
    [[1,1,1]],
    [[1,1,1,1]],
    [[1,1,1,1,1]],
    [[1],[1]],
    [[1],[1],[1]],
    [[1],[1],[1],[1]],
    [[1],[1],[1],[1],[1]],
    // squares
    [[1,1],[1,1]],
    [[1,1,1],[1,1,1],[1,1,1]],
    // L / corners
    [[1,0],[1,0],[1,1]],
    [[0,1],[0,1],[1,1]],
    [[1,1],[1,0],[1,0]],
    [[1,1],[0,1],[0,1]],
    [[1,0,0],[1,0,0],[1,1,1]],
    [[0,0,1],[0,0,1],[1,1,1]],
    [[1,1,1],[1,0,0],[1,0,0]],
    [[1,1,1],[0,0,1],[0,0,1]],
    // T
    [[1,1,1],[0,1,0]],
    [[0,1,0],[1,1,1]],
    [[1,0],[1,1],[1,0]],
    [[0,1],[1,1],[0,1]],
    // Z / S
    [[1,1,0],[0,1,1]],
    [[0,1,1],[1,1,0]],
    [[1,0],[1,1],[0,1]],
    [[0,1],[1,1],[1,0]],
    // chunky
    [[1,1,1],[1,0,1]],
    [[1,1,1],[1,1,0]],
    [[1,1,1],[0,1,1]],
    [[1,1,0],[1,1,1]],
    [[0,1,1],[1,1,1]],
  ];

  const COLORS = ["#ff4d73","#ffcc4d","#33e28a","#2aa1ff","#a855ff","#00e5ff","#ff7a00","#7cff00"];

  // Adventure targets: 10x10 pixel art patterns (0/1)
  const TARGETS = [
    // apple-ish
    (()=>{
      const t = Array.from({length:N}, () => Array(N).fill(0));
      const pts = [
        [4,1],[5,1],[6,1],
        [5,0],
        [5,2],
        [3,2],[4,2],[6,2],[7,2],
        [2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],
        [2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],
        [1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],
        [1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],
        [2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],
        [3,8],[4,8],[5,8],[6,8],[7,8],
        [4,9],[5,9],[6,9]
      ];
      pts.forEach(([x,y])=> t[y][x]=1);
      // stem
      t[1][5]=1; t[2][5]=1; t[1][6]=1;
      return t;
    })(),
    // star-ish
    (()=>{
      const t = Array.from({length:N}, () => Array(N).fill(0));
      const pts = [
        [5,1],
        [4,2],[5,2],[6,2],
        [3,3],[5,3],[7,3],
        [2,4],[5,4],[8,4],
        [1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],
        [2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],
        [3,7],[4,7],[5,7],[6,7],[7,7],
        [4,8],[5,8],[6,8],
        [5,9]
      ];
      pts.forEach(([x,y])=> t[y][x]=1);
      return t;
    })(),
    // heart-ish
    (()=>{
      const t = Array.from({length:N}, () => Array(N).fill(0));
      const pts = [
        [3,2],[4,2],[6,2],[7,2],
        [2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],
        [2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],
        [3,5],[4,5],[5,5],[6,5],[7,5],
        [4,6],[5,6],[6,6],
        [5,7]
      ];
      pts.forEach(([x,y])=> t[y][x]=1);
      // scale to be bigger by mirroring down a bit
      for(let y=8;y<10;y++){
        for(let x=0;x<10;x++){
          if(t[y-3] && t[y-3][x]) t[y][x] = t[y-3][x];
        }
      }
      // trim edges a bit
      t[9][0]=t[9][9]=0;
      return t;
    })(),
  ];

  let target = null; // 10x10 0/1 for adventure
  let targetColor = "#ffffff";

  // current 3 pieces
  let pieces = []; // {shape, color, used:false}

  // -------------------------
  // Render Board
  // -------------------------
  const cellEls = [];
  function buildBoard(){
    boardEl.innerHTML = "";
    cellEls.length = 0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const d = document.createElement("div");
        d.className = "cell";
        d.dataset.x = x;
        d.dataset.y = y;
        boardEl.appendChild(d);
        cellEls.push(d);
      }
    }
  }
  buildBoard();

  function renderBoard(){
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const el = cellEls[idx];
        el.classList.toggle("target", mode==="adventure" && target && target[y][x]===1);
        const v = board[y][x];
        if(v){
          el.classList.add("filled");
          el.style.setProperty("--fill", v);
        }else{
          el.classList.remove("filled");
          el.style.removeProperty("--fill");
        }
      }
    }
  }

  // -------------------------
  // Pieces UI
  // -------------------------
  function shapeTo5x5(shape){
    // shape is 2D array of 0/1 of various size
    const h = shape.length;
    const w = shape[0].length;
    const grid = Array.from({length:5}, ()=> Array(5).fill(0));
    // center it in 5x5
    const offY = Math.floor((5 - h)/2);
    const offX = Math.floor((5 - w)/2);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        grid[offY+y][offX+x] = shape[y][x] ? 1 : 0;
      }
    }
    return grid;
  }

  function renderPieces(){
    piecesEl.innerHTML = "";
    pieces.forEach((p, i) => {
      const slot = document.createElement("div");
      slot.className = "pieceSlot" + (p.used ? " empty" : "");
      slot.dataset.idx = i;

      if(!p.used){
        const piece = document.createElement("div");
        piece.className = "piece";
        piece.style.setProperty("--pcolor", p.color);
        piece.dataset.idx = i;

        const g = shapeTo5x5(p.shape);
        for(let y=0;y<5;y++){
          for(let x=0;x<5;x++){
            const c = document.createElement("div");
            c.className = "pCell" + (g[y][x] ? " on" : "");
            piece.appendChild(c);
          }
        }
        slot.appendChild(piece);

        // drag
        piece.addEventListener("pointerdown", (e)=> startDrag(e, i));
      }else{
        slot.innerHTML = "";
      }
      piecesEl.appendChild(slot);
    });
  }

  // -------------------------
  // Placement logic
  // -------------------------
  function shapeCells(shape){
    // returns list of [sx,sy] coordinates where shape==1
    const out = [];
    for(let y=0;y<shape.length;y++){
      for(let x=0;x<shape[0].length;x++){
        if(shape[y][x]) out.push([x,y]);
      }
    }
    return out;
  }

  function canPlace(shape, bx, by){
    const cells = shapeCells(shape);
    for(const [sx,sy] of cells){
      const x = bx + sx;
      const y = by + sy;
      if(x<0 || x>=N || y<0 || y>=N) return false;
      if(board[y][x]) return false;
    }
    return true;
  }

  function place(shape, color, bx, by){
    const cells = shapeCells(shape);
    for(const [sx,sy] of cells){
      const x = bx + sx;
      const y = by + sy;
      board[y][x] = color;
    }
  }

  function clearLines(){
    const fullRows = [];
    const fullCols = [];

    for(let y=0;y<N;y++){
      let ok = true;
      for(let x=0;x<N;x++){
        if(!board[y][x]) { ok=false; break; }
      }
      if(ok) fullRows.push(y);
    }
    for(let x=0;x<N;x++){
      let ok = true;
      for(let y=0;y<N;y++){
        if(!board[y][x]) { ok=false; break; }
      }
      if(ok) fullCols.push(x);
    }

    if(fullRows.length===0 && fullCols.length===0) return 0;

    // clear anim flash
    clearFlashEl.classList.remove("run");
    void clearFlashEl.offsetWidth;
    clearFlashEl.classList.add("run");

    // Remove blocks with a little delay for punch
    for(const y of fullRows){
      for(let x=0;x<N;x++){
        board[y][x] = null;
      }
    }
    for(const x of fullCols){
      for(let y=0;y<N;y++){
        board[y][x] = null;
      }
    }
    return fullRows.length + fullCols.length;
  }

  function isBoardEmpty(){
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(board[y][x]) return false;
    return true;
  }

  function anyMovePossible(){
    // if any unused piece can be placed anywhere
    for(const p of pieces){
      if(p.used) continue;
      const shape = p.shape;
      for(let by=0;by<N;by++){
        for(let bx=0;bx<N;bx++){
          if(canPlace(shape, bx, by)) return true;
        }
      }
    }
    return false;
  }

  // Adventure completion: all target cells are filled (color doesn't matter)
  function isAdventureComplete(){
    if(mode!=="adventure" || !target) return false;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(target[y][x]===1 && !board[y][x]) return false;
      }
    }
    return true;
  }

  // -------------------------
  // Praise / Toast
  // -------------------------
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.remove("show");
    void toastEl.offsetWidth;
    toastEl.classList.add("show");
  }

  function bigWinFX(kind="level"){
    // fireworks at center of board
    const rect = document.getElementById("boardWrap").getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    if(kind==="level"){
      spawnConfetti(1.2);
      spawnFirework(cx, cy, 1.3);
      spawnFirework(cx - rect.width*0.18, cy + rect.height*0.05, 1.0);
      spawnFirework(cx + rect.width*0.18, cy - rect.height*0.05, 1.0);
    }else{
      spawnConfetti(1.5);
      spawnFirework(cx, cy, 1.6);
      spawnFirework(cx - rect.width*0.25, cy - rect.height*0.10, 1.2);
      spawnFirework(cx + rect.width*0.25, cy - rect.height*0.10, 1.2);
      spawnFirework(cx, cy + rect.height*0.22, 1.0);
    }
  }

  // -------------------------
  // Drag & Drop
  // -------------------------
  let drag = null; // {idx, shape, color, pointerId, offX, offY}
  let lastPreview = [];

  function clearPreview(){
    for(const el of lastPreview){
      el.classList.remove("previewOk","previewBad");
    }
    lastPreview = [];
  }

  function setPreview(bx, by, ok){
    clearPreview();
    if(!drag) return;
    const cells = shapeCells(drag.shape);
    for(const [sx,sy] of cells){
      const x = bx + sx;
      const y = by + sy;
      if(x<0||x>=N||y<0||y>=N) continue;
      const el = cellEls[y*N + x];
      el.classList.add(ok ? "previewOk" : "previewBad");
      lastPreview.push(el);
    }
  }

  function boardCellFromPoint(clientX, clientY){
    const rect = boardEl.getBoundingClientRect();
    const x = (clientX - rect.left) / rect.width;
    const y = (clientY - rect.top) / rect.height;
    const bx = Math.floor(clamp(x, 0, 0.999999) * N);
    const by = Math.floor(clamp(y, 0, 0.999999) * N);
    return {bx, by, inside: clientX>=rect.left && clientX<=rect.right && clientY>=rect.top && clientY<=rect.bottom};
  }

  function buildGhost(shape, color){
    ghostEl.innerHTML = "";
    ghostEl.style.setProperty("--pcolor", color);
    const g = shapeTo5x5(shape);
    for(let y=0;y<5;y++){
      for(let x=0;x<5;x++){
        const c = document.createElement("div");
        c.className = "pCell" + (g[y][x] ? " on" : "");
        ghostEl.appendChild(c);
      }
    }
  }

  function startDrag(e, idx){
    const p = pieces[idx];
    if(!p || p.used) return;

    drag = { idx, shape: p.shape, color: p.color, pointerId: e.pointerId, offX: 0, offY: 0 };
    e.currentTarget.setPointerCapture(e.pointerId);

    buildGhost(p.shape, p.color);
    ghostEl.classList.remove("hidden");

    // center ghost on finger
    moveGhost(e.clientX, e.clientY);

    const onMove = (ev) => {
      if(!drag || ev.pointerId !== drag.pointerId) return;
      moveGhost(ev.clientX, ev.clientY);
      const hit = boardCellFromPoint(ev.clientX, ev.clientY);
      if(hit.inside){
        const ok = canPlace(drag.shape, hit.bx, hit.by);
        setPreview(hit.bx, hit.by, ok);
      }else{
        clearPreview();
      }
    };

    const onUp = (ev) => {
      if(!drag || ev.pointerId !== drag.pointerId) return;
      e.currentTarget.releasePointerCapture(ev.pointerId);

      const hit = boardCellFromPoint(ev.clientX, ev.clientY);
      clearPreview();
      ghostEl.classList.add("hidden");

      if(hit.inside && canPlace(drag.shape, hit.bx, hit.by)){
        doPlace(drag.idx, hit.bx, hit.by);
      }else{
        // little shake feedback
        toast("–ú–∏–º–æ üòÖ");
      }
      drag = null;
      window.removeEventListener("pointermove", onMove);
      window.removeEventListener("pointerup", onUp, true);
      window.removeEventListener("pointercancel", onUp, true);
    };

    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp, true);
    window.addEventListener("pointercancel", onUp, true);
  }

  function moveGhost(x, y){
    const size = 170;
    ghostEl.style.transform = `translate(${x - size/2}px, ${y - size/2}px) scale(1.02)`;
  }

  // -------------------------
  // Game loop actions
  // -------------------------
  function addScore(delta){
    score += delta;
    if(score < 0) score = 0;
    scoreEl.textContent = score;

    // update best
    if(mode==="classic"){
      if(score > bestClassic){
        bestClassic = score;
        localStorage.setItem(key.bestClassic, String(bestClassic));
      }
      bestEl.textContent = bestClassic;
    }else{
      if(score > bestAdventure){
        bestAdventure = score;
        localStorage.setItem(key.bestAdventure, String(bestAdventure));
      }
      bestEl.textContent = bestAdventure;
    }
  }

  function doPlace(idx, bx, by){
    const p = pieces[idx];
    if(!p || p.used) return;

    place(p.shape, p.color, bx, by);
    p.used = true;

    // scoring: blocks placed
    const placedCount = shapeCells(p.shape).length;
    addScore(placedCount * 8);

    // clear
    const cleared = clearLines();
    if(cleared > 0){
      // bonus: lines cleared
      addScore(120 * cleared);
      toast(cleared >= 2 ? "–û–ü–ê! –ö–û–ú–ë–û üî•" : "–ß–ò–°–¢–û!");
    }

    renderBoard();
    renderPieces();

    // BIG moment: board becomes empty after clears (like ‚Äú—Ä–∞–∑—ä–µ–±–∞–ª –ø–æ–ª–µ‚Äù)
    if(isBoardEmpty()){
      toast("–ü–û–õ–ï –í –ù–û–õ–¨ üí•");
      bigWinFX("wipe");
      addScore(500);
    }

    // if all 3 used ‚Äî refresh
    if(pieces.every(x => x.used)){
      newPieces();
    }

    // Adventure level complete
    if(isAdventureComplete()){
      toast("–ö–†–ê–°–ê–í–ê! –£–†–û–í–ï–ù–¨ –ó–ê–ö–†–´–¢ üèÜ");
      bigWinFX("level");
      addScore(900 + adventureLevel * 25);
      nextAdventureLevel();
      return;
    }

    // Game over check
    if(!anyMovePossible()){
      gameOver();
    }
  }

  function newPieces(){
    pieces = Array.from({length:3}, () => ({
      shape: pick(SHAPES),
      color: pick(COLORS),
      used: false
    }));
    renderPieces();
  }

  function resetBoard(){
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) board[y][x] = null;
  }

  function setMode(newMode){
    mode = newMode;
    tabAdvEl.classList.toggle("active", mode==="adventure");
    tabClaEl.classList.toggle("active", mode==="classic");

    if(mode==="adventure"){
      kLeftEl.textContent = "LEVEL";
      vLeftEl.textContent = adventureLevel;
      bestEl.textContent = bestAdventure;
      hintEl.textContent = "Adventure: –∑–∞–∫—Ä–∞—Å—å ‚Äú–∫–∞—Ä—Ç–∏–Ω–∫—É‚Äù (–ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏). Classic: –Ω–∞–±–∏–≤–∞–π —Ä–µ–∫–æ—Ä–¥.";
      shuffleLeft = 1;
      btnShuffle.textContent = "–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Ñ–∏–≥—É—Ä—ã (x1)";
      buildAdventureTarget();
    }else{
      kLeftEl.textContent = "MODE";
      vLeftEl.textContent = "‚àû";
      bestEl.textContent = bestClassic;
      hintEl.textContent = "Classic: –ø—Ä–æ—Å—Ç–æ –¥–æ–ª–±–∏ —Ä–µ–∫–æ—Ä–¥. –ß–∏—Å—Ç–∏—à—å –ª–∏–Ω–∏–∏ ‚Äî –∂–∏–≤—ë—à—å –¥–∞–ª—å—à–µ.";
      shuffleLeft = 1;
      btnShuffle.textContent = "–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Ñ–∏–≥—É—Ä—ã (x1)";
      target = null;
    }
    renderBoard();
  }

  // -------------------------
  // Adventure targets (procedural levels)
  // -------------------------
  function buildAdventureTarget(){
    // pick base pattern, then shift & spice slightly by level
    const base = pick(TARGETS);
    const t = Array.from({length:N}, () => Array(N).fill(0));
    const sx = randi(-1, 1);
    const sy = randi(-1, 1);
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const yy = y - sy;
        const xx = x - sx;
        if(yy>=0 && yy<N && xx>=0 && xx<N){
          t[y][x] = base[yy][xx] ? 1 : 0;
        }
      }
    }
    // level spice: add some random extra pixels for higher levels
    const spice = clamp(Math.floor(adventureLevel/6), 0, 8);
    for(let i=0;i<spice;i++){
      const x = randi(2,7), y = randi(2,7);
      if(Math.random() < 0.5) t[y][x] = 1;
    }

    target = t;
    targetColor = pick(["#ffffff","#d4f6ff","#ffe9c2","#e8dcff","#d9ffe8"]);
    // We don't paint target cells with color; just mark them (CSS)
  }

  function nextAdventureLevel(){
    adventureLevel++;
    localStorage.setItem(key.advLevel, String(adventureLevel));
    vLeftEl.textContent = adventureLevel;

    // Clear board for next ‚Äú–∫–∞—Ä—Ç–∏–Ω–∫–∞‚Äù
    resetBoard();
    buildAdventureTarget();
    newPieces();
    renderBoard();
  }

  // -------------------------
  // Game over / modal
  // -------------------------
  function gameOver(){
    overlayEl.classList.add("show");
    modalTitleEl.textContent = "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
    if(mode==="classic"){
      modalTextEl.textContent = `–•–æ–¥–æ–≤ –Ω–µ—Ç. –†–µ–∫–æ—Ä–¥: ${bestClassic}. –î–∞–≤–∞–π –∑–∞–Ω–æ–≤–æ, –±—Ä–∞—Ç–∞–Ω?`;
    }else{
      modalTextEl.textContent = `–•–æ–¥–æ–≤ –Ω–µ—Ç –Ω–∞ —É—Ä–æ–≤–Ω–µ ${adventureLevel}. –î–∞–≤–∞–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫?`;
    }
  }

  function closeModal(){
    overlayEl.classList.remove("show");
  }

  function restart(){
    closeModal();
    score = 0;
    scoreEl.textContent = "0";
    resetBoard();
    newPieces();

    if(mode==="adventure"){
      buildAdventureTarget();
      vLeftEl.textContent = adventureLevel;
      bestEl.textContent = bestAdventure;
    }else{
      target = null;
      bestEl.textContent = bestClassic;
    }
    shuffleLeft = 1;
    btnShuffle.textContent = "–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Ñ–∏–≥—É—Ä—ã (x1)";
    renderBoard();
  }

  // -------------------------
  // Shuffle (1 per run)
  // -------------------------
  btnShuffle.addEventListener("click", () => {
    if(shuffleLeft <= 0){
      toast("–®–∞—Ñ—Ñ–ª –∑–∞–∫–æ–Ω—á–∏–ª—Å—è üòà");
      return;
    }
    // only shuffle unused pieces
    for(const p of pieces){
      if(!p.used){
        p.shape = pick(SHAPES);
        p.color = pick(COLORS);
      }
    }
    shuffleLeft--;
    btnShuffle.textContent = `–ü–µ—Ä–µ–º–µ—à–∞—Ç—å —Ñ–∏–≥—É—Ä—ã (x${shuffleLeft})`;
    toast("–ü–ï–†–ï–ú–ï–®–ê–õ üí´");
    renderPieces();
  });

  // -------------------------
  // Tabs & buttons
  // -------------------------
  tabAdvEl.addEventListener("click", () => {
    setMode("adventure");
    restart();
  });
  tabClaEl.addEventListener("click", () => {
    setMode("classic");
    restart();
  });

  btnNew.addEventListener("click", () => {
    // in adventure: keep current level, just reset board
    restart();
    toast("–ü–û–ï–•–ê–õ–ò üöÄ");
  });

  btnClose.addEventListener("click", closeModal);
  btnRestart.addEventListener("click", restart);

  overlayEl.addEventListener("click", (e)=>{
    if(e.target === overlayEl) closeModal();
  });

  // -------------------------
  // Init
  // -------------------------
  function init(){
    bestEl.textContent = bestAdventure;
    vLeftEl.textContent = adventureLevel;
    buildAdventureTarget();
    newPieces();
    renderBoard();
    renderPieces();
  }
  init();

  // Safety: prevent scroll on iOS while dragging
  document.addEventListener("touchmove", (e)=> {
    if(drag) e.preventDefault();
  }, {passive:false});

})();
</script>
</body>
</html>
