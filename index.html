<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Rail Dash ‚Äî Runner</title>
  <style>
    :root{
      --bg1:#35b6ff;
      --bg2:#2b3bff;
      --panel: rgba(0,0,0,.35);
      --panel2: rgba(255,255,255,.10);
      --text:#eaf6ff;
      --muted: rgba(234,246,255,.75);
      --good:#2fe084;
      --bad:#ff4d73;
      --gold:#ffcc4d;
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --soft: 0 10px 22px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%; margin:0; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{
      color:var(--text);
      overflow:hidden;
      background:
        radial-gradient(1000px 700px at 20% 20%, rgba(255,204,77,.25), transparent 55%),
        radial-gradient(900px 600px at 80% 35%, rgba(47,224,132,.18), transparent 55%),
        radial-gradient(900px 700px at 60% 85%, rgba(168,85,255,.16), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      user-select:none;
    }

    canvas{position:fixed; inset:0; width:100%; height:100%;}

    .hud{
      position:fixed; inset:0;
      pointer-events:none;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      display:flex; flex-direction:column;
      gap:10px;
      z-index:10;
    }
    .topbar{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .leftTop{display:flex; gap:10px; align-items:flex-start;}
    .btnIcon{
      pointer-events:auto;
      width:48px; height:48px;
      border-radius:16px;
      display:grid; place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.08));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--soft);
      font-weight:1000;
      cursor:pointer;
    }
    .pill{
      pointer-events:auto;
      min-width:140px;
      padding:10px 12px;
      border-radius:18px;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22));
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--soft);
      backdrop-filter: blur(10px);
    }
    .pill .k{font-size:11px; font-weight:900; color:var(--muted);}
    .pill .v{margin-top:2px; font-size:18px; font-weight:1000; letter-spacing:.4px; display:flex; gap:8px; align-items:center;}
    .coin{display:inline-grid; place-items:center; width:22px; height:22px; border-radius:9px;
      background: linear-gradient(180deg, rgba(255,204,77,.95), rgba(255,166,0,.88));
      color:#3a2500; font-size:14px; box-shadow: 0 10px 16px rgba(0,0,0,.22);
    }
    .key{display:inline-grid; place-items:center; width:22px; height:22px; border-radius:9px;
      background: linear-gradient(180deg, rgba(135,255,255,.95), rgba(42,161,255,.88));
      color:#052a3a; font-size:14px; box-shadow: 0 10px 16px rgba(0,0,0,.22);
    }

    .toast{
      position:fixed;
      left:50%; top: calc(env(safe-area-inset-top) + 64px);
      transform: translateX(-50%);
      padding:10px 14px;
      border-radius:16px;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      font-weight:1000;
      letter-spacing:.3px;
      opacity:0;
      z-index:20;
      pointer-events:none;
      white-space:nowrap;
    }
    .toast.show{ animation: toastPop .95s ease forwards; }
    @keyframes toastPop{
      0%{opacity:0; transform:translateX(-50%) translateY(-10px) scale(.98);}
      15%{opacity:1; transform:translateX(-50%) translateY(0) scale(1);}
      80%{opacity:1;}
      100%{opacity:0; transform:translateX(-50%) translateY(-10px) scale(.98);}
    }

    .menu{
      position:fixed; inset:0;
      display:grid; place-items:center;
      padding:16px;
      z-index:30;
      background:
        radial-gradient(1000px 700px at 20% 20%, rgba(255,204,77,.25), transparent 55%),
        radial-gradient(900px 600px at 80% 35%, rgba(47,224,132,.18), transparent 55%),
        radial-gradient(900px 700px at 60% 85%, rgba(168,85,255,.16), transparent 60%),
        linear-gradient(180deg, rgba(10,25,88,.95), rgba(7,14,42,.95));
      backdrop-filter: blur(10px);
    }
    .card{
      width:min(560px, 96vw);
      border-radius:28px;
      padding:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .card:before{
      content:"";
      position:absolute; inset:-60%;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,204,77,.28), transparent 58%),
        radial-gradient(circle at 75% 60%, rgba(47,224,132,.20), transparent 62%),
        radial-gradient(circle at 40% 75%, rgba(42,161,255,.18), transparent 62%);
      transform: rotate(18deg);
      pointer-events:none;
    }
    .cardInner{position:relative;}
    .brand{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .title{
      font-weight:1000; letter-spacing:.7px; font-size:22px;
    }
    .subtitle{margin-top:4px; color:var(--muted); font-weight:800; font-size:12px;}
    .statsRow{
      margin-top:12px;
      display:flex; flex-wrap:wrap; gap:10px;
    }
    .stat{
      flex:1;
      min-width:160px;
      padding:10px 12px;
      border-radius:18px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--soft);
    }
    .stat .k{font-size:11px; font-weight:900; color:var(--muted);}
    .stat .v{margin-top:2px; font-size:18px; font-weight:1000;}
    .tabs{
      margin-top:12px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .tab{
      pointer-events:auto;
      border:none; cursor:pointer;
      padding:10px 12px;
      border-radius:16px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      font-weight:1000;
      box-shadow: var(--soft);
    }
    .tab.sel{
      background: linear-gradient(180deg, rgba(47,224,132,.95), rgba(30,207,118,.88));
      color:#07321e;
      border-color: rgba(47,224,132,.35);
    }
    .section{margin-top:12px;}
    .grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    @media (max-width: 520px){
      .grid{grid-template-columns: repeat(2, 1fr);}
      .stat{min-width:140px;}
    }
    .item{
      padding:10px;
      border-radius:18px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--soft);
      pointer-events:auto;
      cursor:pointer;
      transition: transform .12s ease;
      position:relative;
      overflow:hidden;
    }
    .item:active{transform: translateY(1px) scale(.99);}
    .item .name{font-weight:1000; letter-spacing:.2px;}
    .item .desc{margin-top:4px; color:var(--muted); font-weight:800; font-size:12px;}
    .badge{
      position:absolute; top:10px; right:10px;
      padding:6px 10px;
      border-radius:14px;
      font-weight:1000;
      font-size:12px;
      background: rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.12);
    }
    .badge.lock{background: rgba(255,77,115,.18); border-color: rgba(255,77,115,.25);}
    .badge.own{background: rgba(47,224,132,.18); border-color: rgba(47,224,132,.25);}

    .actions{margin-top:14px; display:flex; gap:10px;}
    .btn{
      pointer-events:auto;
      border:none; cursor:pointer;
      border-radius:18px;
      padding:12px 14px;
      font-weight:1000; letter-spacing:.4px;
      box-shadow: var(--shadow);
      transition: transform .12s ease;
      flex:1;
    }
    .btn:active{transform: translateY(1px) scale(.99);}
    .btn.play{background: linear-gradient(180deg, rgba(47,224,132,.98), rgba(30,207,118,.92)); color:#08321e;}
    .btn.ghost{background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08)); color:var(--text); box-shadow: var(--soft);}
    .btn.danger{background: linear-gradient(180deg, rgba(255,77,115,.95), rgba(230,50,95,.90)); color:#2d0612;}

    .modal{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      padding:16px;
      z-index:40;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .modal.show{display:grid;}
    .modalCard{
      width:min(520px, 96vw);
      border-radius:26px;
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
    }
    .modalCard h2{margin:0 0 6px; font-size:18px;}
    .modalCard p{margin:0 0 12px; color:var(--muted); font-weight:800;}
    .rewardRow{
      display:flex; flex-wrap:wrap; gap:10px;
      margin:10px 0 12px;
    }
    .reward{
      flex:1; min-width:140px;
      padding:10px 12px;
      border-radius:18px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--soft);
      font-weight:1000;
    }
    .small{font-size:12px; color:var(--muted); font-weight:900;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud" id="hud">
    <div class="topbar">
      <div class="leftTop">
        <button class="btnIcon" id="btnPause" title="–ü–∞—É–∑–∞">‚è∏</button>
        <div class="pill">
          <div class="k">–°–ß–Å–¢</div>
          <div class="v" id="uiScore">0</div>
        </div>
      </div>

      <div style="display:flex; gap:10px; align-items:flex-start;">
        <div class="pill">
          <div class="k">–ö–û–ú–ë–û</div>
          <div class="v" id="uiCombo">x1</div>
        </div>
        <div class="pill">
          <div class="k">–õ–£–¢</div>
          <div class="v">
            <span class="coin">‚òÖ</span><span id="uiCoins">0</span>
            <span class="key">üîë</span><span id="uiKeys">0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast">–ö–†–ê–°–ê–í–ê!</div>
  </div>

  <div class="menu" id="menu">
    <div class="card">
      <div class="cardInner">
        <div class="brand">
          <div>
            <div class="title">RAIL DASH</div>
            <div class="subtitle">3 –ø–æ–ª–æ—Å—ã ‚Ä¢ –ø—Ä—ã–∂–æ–∫/–ø–æ–¥–∫–∞—Ç ‚Ä¢ –º–∏—Å—Å–∏–∏ ‚Ä¢ —Å—É–Ω–¥—É–∫–∏ ‚Ä¢ —Å–∫–∏–Ω—ã/–¥–æ—Å–∫–∏</div>
          </div>
          <div class="btnIcon" id="btnSettings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏/–¥–∞–Ω–Ω—ã–µ">‚öôÔ∏è</div>
        </div>

        <div class="statsRow">
          <div class="stat">
            <div class="k">HIGH SCORE</div>
            <div class="v" id="mBest">0</div>
          </div>
          <div class="stat">
            <div class="k">–õ–£–¢</div>
            <div class="v"><span class="coin">‚òÖ</span> <span id="mCoins">0</span> &nbsp; <span class="key">üîë</span> <span id="mKeys">0</span></div>
          </div>
          <div class="stat">
            <div class="k">–°–£–ù–î–£–ö–ò</div>
            <div class="v" id="mChests">0</div>
          </div>
        </div>

        <div class="tabs">
          <button class="tab sel" data-tab="missions">–ú–∏—Å—Å–∏–∏</button>
          <button class="tab" data-tab="chests">–°—É–Ω–¥—É–∫–∏</button>
          <button class="tab" data-tab="shop">–ú–∞–≥–∞–∑–∏–Ω</button>
          <button class="tab" data-tab="locker">–ü–µ—Ä—Å—ã/–î–æ—Å–∫–∏</button>
        </div>

        <div class="section" id="tab_missions"></div>
        <div class="section" id="tab_chests" style="display:none;"></div>
        <div class="section" id="tab_shop" style="display:none;"></div>
        <div class="section" id="tab_locker" style="display:none;"></div>

        <div class="actions">
          <button class="btn play" id="btnPlay">–ò–ì–†–ê–¢–¨</button>
          <button class="btn ghost" id="btnHow">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard" id="modalCard">
      <h2 id="modalTitle">–û–∫–Ω–æ</h2>
      <p id="modalText">–¢–µ–∫—Å—Ç</p>
      <div class="rewardRow" id="rewardRow" style="display:none;"></div>
      <div class="actions">
        <button class="btn ghost" id="btnModalClose">–ó–∞–∫—Ä—ã—Ç—å</button>
        <button class="btn play" id="btnModalOk" style="display:none;">–û–∫</button>
      </div>
      <div class="small" id="modalHint" style="margin-top:10px;"></div>
    </div>
  </div>

<script>
(()=> {
  // ====== STORAGE ======
  const KEY = "rail_dash_save_v1";
  const defaultSave = () => ({
    coins: 0,
    keys: 0,
    chests: 0,
    best: 0,
    ownedChars: { "Rookie": true },
    ownedBoards: { "Basic": true },
    activeChar: "Rookie",
    activeBoard: "Basic",
    boardStock: { "Basic": 1, "Shield": 0, "Turbo": 0 },
    stats: { runs:0, meters:0, coins:0, jumps:0, rolls:0 },
    missions: []
  });

  function load(){
    try{
      const raw = localStorage.getItem(KEY);
      if(!raw) return defaultSave();
      const s = JSON.parse(raw);
      return Object.assign(defaultSave(), s);
    }catch(e){
      return defaultSave();
    }
  }
  function saveNow(){
    localStorage.setItem(KEY, JSON.stringify(S));
    renderMenu();
  }
  let S = load();

  // ====== DOM ======
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");
  const hud = document.getElementById("hud");
  const menu = document.getElementById("menu");

  const uiScore = document.getElementById("uiScore");
  const uiCombo = document.getElementById("uiCombo");
  const uiCoins = document.getElementById("uiCoins");
  const uiKeys  = document.getElementById("uiKeys");
  const toastEl = document.getElementById("toast");
  const btnPause = document.getElementById("btnPause");

  const mBest = document.getElementById("mBest");
  const mCoins = document.getElementById("mCoins");
  const mKeys  = document.getElementById("mKeys");
  const mChests= document.getElementById("mChests");

  const btnPlay = document.getElementById("btnPlay");
  const btnHow  = document.getElementById("btnHow");
  const btnSettings = document.getElementById("btnSettings");

  const modal = document.getElementById("modal");
  const modalTitle = document.getElementById("modalTitle");
  const modalText  = document.getElementById("modalText");
  const rewardRow  = document.getElementById("rewardRow");
  const btnModalClose = document.getElementById("btnModalClose");
  const btnModalOk = document.getElementById("btnModalOk");
  const modalHint = document.getElementById("modalHint");

  const tabM = document.getElementById("tab_missions");
  const tabC = document.getElementById("tab_chests");
  const tabS = document.getElementById("tab_shop");
  const tabL = document.getElementById("tab_locker");

  function toast(t){
    toastEl.textContent = t;
    toastEl.classList.remove("show");
    void toastEl.offsetWidth;
    toastEl.classList.add("show");
  }

  function showModal(title, text, {okText=null, onOk=null, rewards=null, hint=""} = {}){
    modalTitle.textContent = title;
    modalText.textContent = text;
    modalHint.textContent = hint || "";
    rewardRow.innerHTML = "";
    if(rewards && rewards.length){
      rewardRow.style.display = "flex";
      for(const r of rewards){
        const d = document.createElement("div");
        d.className = "reward";
        d.innerHTML = `<div class="small">${r.k}</div><div style="font-size:18px;margin-top:2px;">${r.v}</div>`;
        rewardRow.appendChild(d);
      }
    } else {
      rewardRow.style.display = "none";
    }
    btnModalOk.style.display = okText ? "inline-block" : "none";
    btnModalOk.textContent = okText || "";
    btnModalOk.onclick = () => { if(onOk) onOk(); hideModal(); };
    modal.classList.add("show");
  }
  function hideModal(){ modal.classList.remove("show"); }
  btnModalClose.addEventListener("click", hideModal);
  modal.addEventListener("click", (e)=>{ if(e.target===modal) hideModal(); });

  // ====== CANVAS RESIZE ======
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    c.width = W; c.height = H;
  }
  addEventListener("resize", resize);
  resize();

  // ====== GAME CONFIG ======
  const lanes = [-1, 0, 1];
  const laneX = (lane) => W*0.5 + lane*(W*0.18);
  const groundY = () => H*0.82;
  const horizonY = () => H*0.18;

  // obstacles types
  const OB = {
    BARRIER: "barrier",   // jump
    LOWBAR: "lowbar",     // roll
    TRAIN: "train"        // avoid lane
  };

  // ====== CONTENT (OWN ART, NOT IP) ======
  const Characters = [
    {id:"Rookie", name:"Rookie", priceCoins:0, priceKeys:0, color:"#ffffff"},
    {id:"Neon",   name:"Neon",   priceCoins:2500, priceKeys:2, color:"#00e5ff"},
    {id:"Rose",   name:"Rose",   priceCoins:3500, priceKeys:3, color:"#ff4d73"},
    {id:"Goldie", name:"Goldie", priceCoins:5000, priceKeys:5, color:"#ffcc4d"},
    {id:"Violet", name:"Violet", priceCoins:4500, priceKeys:4, color:"#a855ff"},
  ];

  const Boards = [
    {id:"Basic",  name:"Basic",  priceCoins:0,    priceKeys:0,  effect:"1 stock always", color:"#33e28a"},
    {id:"Shield", name:"Shield", priceCoins:1800, priceKeys:2,  effect:"10s shield", color:"#2aa1ff"},
    {id:"Turbo",  name:"Turbo",  priceCoins:2200, priceKeys:2,  effect:"speed boost", color:"#ff7a00"},
  ];

  // ====== MISSIONS ======
  const MissionTypes = [
    { id:"meters",  label:"–ü—Ä–æ–±–µ–≥–∏", unit:"–º", gen:()=>rndInt(800, 2500) },
    { id:"coins",   label:"–°–æ–±–µ—Ä–∏",  unit:"–º–æ–Ω–µ—Ç", gen:()=>rndInt(80, 260) },
    { id:"jumps",   label:"–ü—Ä—ã–∂–∫–æ–≤", unit:"—Ä–∞–∑", gen:()=>rndInt(12, 40) },
    { id:"rolls",   label:"–ü–æ–¥–∫–∞—Ç–æ–≤", unit:"—Ä–∞–∑", gen:()=>rndInt(10, 35) },
    { id:"runs",    label:"–ó–∞–±–µ–≥–æ–≤", unit:"—Ä–∞–∑", gen:()=>rndInt(2, 6) },
  ];

  function ensureMissions(){
    if(!Array.isArray(S.missions) || S.missions.length===0){
      S.missions = [];
    }
    while(S.missions.length < 3){
      const t = pick(MissionTypes);
      // –Ω–µ –¥–µ–ª–∞–µ–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–æ–¥—Ä—è–¥
      if(S.missions.some(m=>m.type===t.id)) continue;
      const target = t.gen();
      const rewardCoins = rndInt(300, 900);
      const rewardKeys  = Math.random()<0.25 ? 1 : 0;
      const rewardChest = Math.random()<0.35 ? 1 : 0;

      S.missions.push({
        id: cryptoRandomId(),
        type: t.id,
        target,
        progress: 0,
        done: false,
        rewards: { coins: rewardCoins, keys: rewardKeys, chests: rewardChest }
      });
    }
  }

  function cryptoRandomId(){
    return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
  }

  // ====== CHESTS / DROPS ======
  const LootTable = [
    // coins
    { kind:"coins", w: 40, roll:()=>({coins: rndInt(150, 600)}) },
    // keys
    { kind:"keys", w: 18, roll:()=>({keys: rndInt(1, 2)}) },
    // board stock
    { kind:"board", w: 20, roll:()=>({board: pick(["Shield","Turbo"]), qty: 1}) },
    // character unlock (rare)
    { kind:"char",  w: 12, roll:()=>({char: pick(["Neon","Rose","Violet","Goldie"])}) },
    // big coins (rare)
    { kind:"big",   w: 10, roll:()=>({coins: rndInt(900, 1800), keys: (Math.random()<0.35?1:0)}) },
  ];
  function weightedPick(table){
    const sum = table.reduce((a,b)=>a+b.w,0);
    let r = Math.random()*sum;
    for(const it of table){
      r -= it.w;
      if(r<=0) return it;
    }
    return table[table.length-1];
  }
  function openChest(){
    if(S.chests<=0){ toast("–°—É–Ω–¥—É–∫–æ–≤ –Ω–µ—Ç üòà"); return; }
    S.chests--;
    const drop = weightedPick(LootTable).roll();

    const rewards = [];
    if(drop.coins){ S.coins += drop.coins; rewards.push({k:"–ú–æ–Ω–µ—Ç—ã", v:`${drop.coins} ‚òÖ`}); }
    if(drop.keys){  S.keys  += drop.keys;  rewards.push({k:"–ö–ª—é—á–∏",  v:`${drop.keys} üîë`}); }
    if(drop.board){
      S.boardStock[drop.board] = (S.boardStock[drop.board]||0) + (drop.qty||1);
      const b = Boards.find(x=>x.id===drop.board);
      rewards.push({k:"–î–æ—Å–∫–∞", v:`${b?b.name:drop.board} +${drop.qty||1}`});
    }
    if(drop.char){
      S.ownedChars[drop.char] = true;
      const ch = Characters.find(x=>x.id===drop.char);
      rewards.push({k:"–°–∫–∏–Ω", v:`${ch?ch.name:drop.char} ‚úÖ`});
    }

    saveNow();
    showModal("–°—É–Ω–¥—É–∫ –æ—Ç–∫—Ä—ã—Ç üéÅ", "–õ–æ–≤–∏ –Ω–∞–≥—Ä–∞–¥—É:", {rewards, hint:"–†–µ–¥–∫–æ—Å—Ç—å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É–¥–∞—á–∏. –ß–µ–º –±–æ–ª—å—à–µ –∏–≥—Ä–∞–µ—à—å ‚Äî —Ç–µ–º –±–æ–ª—å—à–µ —Å—É–Ω–¥—É–∫–æ–≤ —Å –º–∏—Å—Å–∏–π."});
  }

  // ====== SHOP ======
  function buyCharacter(id){
    const ch = Characters.find(x=>x.id===id);
    if(!ch) return;
    if(S.ownedChars[id]){ S.activeChar = id; saveNow(); toast(`–í—ã–±—Ä–∞–Ω: ${ch.name}`); return; }
    if(S.coins < ch.priceCoins || S.keys < ch.priceKeys){
      toast("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç üòà");
      return;
    }
    S.coins -= ch.priceCoins;
    S.keys  -= ch.priceKeys;
    S.ownedChars[id] = true;
    S.activeChar = id;
    saveNow();
    toast(`–ö—É–ø–ª–µ–Ω–æ: ${ch.name} ‚úÖ`);
  }

  function buyBoard(id){
    const b = Boards.find(x=>x.id===id);
    if(!b) return;
    if(!S.ownedBoards[id]){
      if(S.coins < b.priceCoins || S.keys < b.priceKeys){
        toast("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç üòà");
        return;
      }
      S.coins -= b.priceCoins;
      S.keys  -= b.priceKeys;
      S.ownedBoards[id] = true;
    }
    // –ø–æ–∫—É–ø–∫–∞ —Å—Ç–æ–∫–∞ (–∫—Ä–æ–º–µ Basic)
    if(id !== "Basic"){
      if(S.coins < 400){
        toast("–ù–∞–¥–æ 400‚òÖ –Ω–∞ –∑–∞—Ä—è–¥ –¥–æ—Å–∫–∏");
        return;
      }
      S.coins -= 400;
      S.boardStock[id] = (S.boardStock[id]||0) + 1;
      toast(`${b.name} +1 –∑–∞—Ä—è–¥`);
    } else {
      toast("Basic –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞");
    }
    saveNow();
  }

  // ====== UI MENU RENDER ======
  function renderMenu(){
    mBest.textContent = Math.floor(S.best);
    mCoins.textContent = Math.floor(S.coins);
    mKeys.textContent  = Math.floor(S.keys);
    mChests.textContent= Math.floor(S.chests);

    // tabs
    renderMissions();
    renderChests();
    renderShop();
    renderLocker();
  }

  function missionLine(m){
    const t = MissionTypes.find(x=>x.id===m.type);
    const label = t ? t.label : m.type;
    const unit = t ? t.unit : "";
    const pct = Math.min(1, m.progress / m.target);
    const done = m.done;
    const r = m.rewards;
    const rewardsStr = `${r.coins||0}‚òÖ${r.keys?(" +"+r.keys+"üîë"):""}${r.chests?(" +"+r.chests+"üéÅ"):""}`;

    return `
      <div class="item" data-mid="${m.id}">
        <div class="badge ${done?"own":"lock"}">${done?"–ì–û–¢–û–í–û":"–í –ü–†–û–¶–ï–°–°–ï"}</div>
        <div class="name">${label} <span style="color:var(--gold)">${m.target}</span> ${unit}</div>
        <div class="desc">–ü—Ä–æ–≥—Ä–µ—Å—Å: ${Math.min(m.progress, m.target)} / ${m.target} ‚Ä¢ –ù–∞–≥—Ä–∞–¥–∞: ${rewardsStr}</div>
        <div style="margin-top:8px;height:10px;border-radius:10px;background:rgba(255,255,255,.10);overflow:hidden;">
          <div style="height:100%;width:${Math.floor(pct*100)}%;background:linear-gradient(90deg, rgba(47,224,132,.95), rgba(255,204,77,.92));"></div>
        </div>
      </div>
    `;
  }

  function renderMissions(){
    ensureMissions();
    tabM.innerHTML = `
      <div class="grid">
        ${S.missions.map(missionLine).join("")}
      </div>
      <div class="small" style="margin-top:10px;">
        –ú–∏—Å—Å–∏–∏ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –í—ã–ø–æ–ª–Ω–∏–ª ‚Äî –ø–æ–ª—É—á–∞–µ—à—å –Ω–∞–≥—Ä–∞–¥—ã —Å—Ä–∞–∑—É.
      </div>
    `;
  }

  function renderChests(){
    tabC.innerHTML = `
      <div class="item" id="openChestBtn">
        <div class="badge">${S.chests} üéÅ</div>
        <div class="name">–û—Ç–∫—Ä—ã—Ç—å —Å—É–Ω–¥—É–∫</div>
        <div class="desc">–õ—É—Ç: –º–æ–Ω–µ—Ç—ã, –∫–ª—é—á–∏, –∑–∞—Ä—è–¥—ã –¥–æ—Å–æ–∫, –∏–Ω–æ–≥–¥–∞ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–∂–∏.</div>
      </div>
      <div class="small" style="margin-top:10px;">
        –°—É–Ω–¥—É–∫–∏ –ø–∞–¥–∞—é—Ç –∏–∑ –º–∏—Å—Å–∏–π. –†–µ–¥–∫–∏–µ –Ω–∞–≥—Ä–∞–¥—ã –±—ã–≤–∞—é—Ç, –Ω–æ –Ω–µ –≤—Å–µ–≥–¥–∞ ‚Äî —Ç–∞–∫ –∏ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å üòà
      </div>
    `;
    setTimeout(()=>{
      const b = document.getElementById("openChestBtn");
      if(b) b.onclick = openChest;
    },0);
  }

  function renderShop(){
    tabS.innerHTML = `
      <div class="small">–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ –∏ –¥–æ—Å–∫–∏ ‚Äî –∑–∞ –º–æ–Ω–µ—Ç—ã –∏ –∫–ª—é—á–∏. –ó–∞—Ä—è–¥—ã –¥–æ—Å–æ–∫ (Shield/Turbo) ‚Äî –º–æ–∂–Ω–æ –¥–æ–∫—É–ø–∞—Ç—å.</div>
      <div style="height:10px;"></div>
      <div class="grid" id="shopGrid"></div>
    `;
    setTimeout(()=>{
      const g = document.getElementById("shopGrid");
      if(!g) return;

      // Characters
      for(const ch of Characters){
        const owned = !!S.ownedChars[ch.id];
        const active = S.activeChar===ch.id;
        const price = (ch.priceCoins||0) + "‚òÖ" + (ch.priceKeys?(" +"+ch.priceKeys+"üîë"):"");
        const badge = active ? `<div class="badge own">–í–´–ë–†–ê–ù</div>` :
                      owned ? `<div class="badge own">–ï–°–¢–¨</div>` :
                              `<div class="badge lock">${price}</div>`;
        const div = document.createElement("div");
        div.className="item";
        div.innerHTML = `${badge}
          <div class="name">–ü–µ—Ä—Å: ${ch.name}</div>
          <div class="desc">–°—Ç–∏–ª—å: —Ü–≤–µ—Ç–Ω–æ–π —Ç—Ä–µ–∫ ‚Ä¢ ${owned?"–ù–∞–∂–º–∏ —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å":"–ù–∞–∂–º–∏ —á—Ç–æ–±—ã –∫—É–ø–∏—Ç—å"}</div>`;
        div.onclick = ()=>buyCharacter(ch.id);
        g.appendChild(div);
      }

      // Boards
      for(const b of Boards){
        const owned = !!S.ownedBoards[b.id];
        const stock = (S.boardStock[b.id]||0);
        const price = (b.priceCoins||0) + "‚òÖ" + (b.priceKeys?(" +"+b.priceKeys+"üîë"):"");
        const badge = (b.id==="Basic")
          ? `<div class="badge own">–ë–ï–°–ü–õ–ê–¢–ù–û</div>`
          : (owned ? `<div class="badge">–ó–ê–†–Ø–î–´: ${stock}</div>` : `<div class="badge lock">${price}</div>`);

        const div = document.createElement("div");
        div.className="item";
        div.innerHTML = `${badge}
          <div class="name">–î–æ—Å–∫–∞: ${b.name}</div>
          <div class="desc">${b.effect}${b.id!=="Basic" ? " ‚Ä¢ +1 –∑–∞—Ä—è–¥ –∑–∞ 400‚òÖ" : ""}</div>`;
        div.onclick = ()=>buyBoard(b.id);
        g.appendChild(div);
      }
    },0);
  }

  function renderLocker(){
    const activeCh = S.activeChar;
    const activeB  = S.activeBoard;

    const charLines = Characters.map(ch=>{
      const owned = !!S.ownedChars[ch.id];
      const active = activeCh===ch.id;
      return `
        <div class="item" data-char="${ch.id}">
          <div class="badge ${owned?"own":"lock"}">${active?"–ê–ö–¢–ò–í":" " + (owned?"–ï–°–¢–¨":"–ó–ê–ö–†–´–¢")}</div>
          <div class="name">${ch.name}</div>
          <div class="desc">${owned ? "–ù–∞–∂–º–∏ ‚Äî –≤—ã–±—Ä–∞—Ç—å" : "–ö—É–ø–∏ –≤ –º–∞–≥–∞–∑–∏–Ω–µ"}</div>
        </div>
      `;
    }).join("");

    const boardLines = Boards.map(b=>{
      const owned = !!S.ownedBoards[b.id];
      const active = activeB===b.id;
      const stock = (S.boardStock[b.id]||0);
      return `
        <div class="item" data-board="${b.id}">
          <div class="badge ${owned?"own":"lock"}">${active?"–ê–ö–¢–ò–í": (owned? (b.id==="Basic"?"–ï–°–¢–¨":("–ó–ê–†–Ø–î–´ "+stock)):"–ó–ê–ö–†–´–¢")}</div>
          <div class="name">${b.name}</div>
          <div class="desc">${b.effect}${owned ? " ‚Ä¢ –ù–∞–∂–º–∏ ‚Äî –≤—ã–±—Ä–∞—Ç—å" : ""}</div>
        </div>
      `;
    }).join("");

    tabL.innerHTML = `
      <div class="small">–í—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ –¥–æ—Å–∫—É. –í –∏–≥—Ä–µ: B ‚Äî –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –¥–æ—Å–∫—É (Shield/Turbo), –µ—Å–ª–∏ –µ—Å—Ç—å –∑–∞—Ä—è–¥.</div>
      <div style="height:10px;"></div>
      <div class="grid">${charLines}</div>
      <div style="height:10px;"></div>
      <div class="grid">${boardLines}</div>
    `;

    setTimeout(()=>{
      tabL.querySelectorAll("[data-char]").forEach(el=>{
        el.onclick = ()=>{
          const id = el.getAttribute("data-char");
          if(S.ownedChars[id]){
            S.activeChar = id;
            saveNow();
            toast("–ü–µ—Ä—Å –≤—ã–±—Ä–∞–Ω ‚úÖ");
          } else toast("–°–Ω–∞—á–∞–ª–∞ –∫—É–ø–∏ üòà");
        };
      });
      tabL.querySelectorAll("[data-board]").forEach(el=>{
        el.onclick = ()=>{
          const id = el.getAttribute("data-board");
          if(S.ownedBoards[id]){
            S.activeBoard = id;
            saveNow();
            toast("–î–æ—Å–∫–∞ –≤—ã–±—Ä–∞–Ω–∞ ‚úÖ");
          } else toast("–°–Ω–∞—á–∞–ª–∞ –∫—É–ø–∏ üòà");
        };
      });
    },0);
  }

  // Tabs switching
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("sel"));
      t.classList.add("sel");
      const k = t.dataset.tab;
      tabM.style.display = (k==="missions")?"block":"none";
      tabC.style.display = (k==="chests")?"block":"none";
      tabS.style.display = (k==="shop")?"block":"none";
      tabL.style.display = (k==="locker")?"block":"none";
    });
  });

  btnHow.addEventListener("click", ()=>{
    showModal("–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", "–°–≤–∞–π–ø—ã –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏:\n‚Äî –í–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ: —Å–º–µ–Ω–∏—Ç—å –ø–æ–ª–æ—Å—É\n‚Äî –í–≤–µ—Ä—Ö: –ø—Ä—ã–∂–æ–∫\n‚Äî –í–Ω–∏–∑: –ø–æ–¥–∫–∞—Ç\n‚Äî B: –¥–æ—Å–∫–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å –∑–∞—Ä—è–¥)\n‚Äî P: –ø–∞—É–∑–∞", {hint:"–¶–µ–ª—å: –≤—ã–∂–∏—Ç—å, —Å–æ–±–∏—Ä–∞—Ç—å –º–æ–Ω–µ—Ç—ã, –≤—ã–ø–æ–ª–Ω—è—Ç—å –º–∏—Å—Å–∏–∏. –°—É–Ω–¥—É–∫–∏ ‚Äî –∏–∑ –º–∏—Å—Å–∏–π."});
  });

  btnSettings.addEventListener("click", ()=>{
    showModal("–î–∞–Ω–Ω—ã–µ", "–ú–æ–∂–Ω–æ —Å–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å (–æ—Å—Ç–æ—Ä–æ–∂–Ω–æ).", {
      okText:"–°–±—Ä–æ—Å–∏—Ç—å –≤—Å—ë",
      onOk: ()=>{
        S = defaultSave();
        saveNow();
        toast("–°–±—Ä–æ—à–µ–Ω–æ");
      },
      hint:"–°–±—Ä–æ—Å —É–¥–∞–ª–∏—Ç —Ä–µ–∫–æ—Ä–¥, –ª—É—Ç, –ø–æ–∫—É–ø–∫–∏ –∏ –º–∏—Å—Å–∏–∏."
    });
  });

  // ====== UTIL ======
  function rndInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // ====== GAME STATE ======
  let running = false;
  let paused = false;

  let tPrev = 0;
  let time = 0;

  // Player
  const P = {
    lane: 0,
    laneX: 0,
    y: 0,
    vy: 0,
    jump: false,
    roll: false,
    rollT: 0,
    alive: true,
    invulnT: 0,       // shield time
    turboT: 0,        // turbo time
  };

  // Run stats
  let score = 0;
  let combo = 1;
  let comboDecay = 0; // decays if no coins/near misses
  let meters = 0;
  let runCoins = 0;

  let speed = 10;     // base speed
  let z = 0;          // forward distance for spawning

  const entities = []; // obstacles & coins & trains

  // ====== SPAWN ======
  function spawnPattern(){
    // choose pattern by difficulty
    const d = Math.min(1, meters/2500);
    const gap = lerp(52, 34, d); // smaller = harder
    const baseZ = z + gap;

    // chance train
    if(Math.random() < lerp(0.10, 0.22, d)){
      const lane = pick(lanes);
      entities.push({type:OB.TRAIN, lane, z: baseZ, w:1.0, h:1.0, kind:"ob"});
      // coins in other lane
      if(Math.random()<0.6){
        const lane2 = pick(lanes.filter(x=>x!==lane));
        spawnCoinsLine(lane2, baseZ+10, 10);
      }
      return;
    }

    // barrier / lowbar combos
    const laneA = pick(lanes);
    const r = Math.random();
    if(r < 0.55){
      entities.push({type:OB.BARRIER, lane: laneA, z: baseZ, kind:"ob"});
      spawnCoinsArc(laneA, baseZ+2, 7);
    } else {
      entities.push({type:OB.LOWBAR, lane: laneA, z: baseZ, kind:"ob"});
      spawnCoinsLine(laneA, baseZ+6, 8);
    }

    // sometimes block another lane lightly
    if(Math.random() < lerp(0.15, 0.35, d)){
      const laneB = pick(lanes.filter(x=>x!==laneA));
      const type = Math.random()<0.5?OB.BARRIER:OB.LOWBAR;
      entities.push({type, lane: laneB, z: baseZ + rndInt(7, 12), kind:"ob"});
    }
  }

  function spawnCoinsLine(lane, startZ, count){
    for(let i=0;i<count;i++){
      entities.push({kind:"coin", lane, z:startZ + i*3.8, taken:false});
    }
  }
  function spawnCoinsArc(lane, startZ, count){
    for(let i=0;i<count;i++){
      entities.push({kind:"coin", lane, z:startZ + i*2.7, arc:i, taken:false});
    }
  }

  // ====== MISSION PROGRESS ======
  function addMissionProgress(type, val){
    let changed = false;
    for(const m of S.missions){
      if(m.done) continue;
      if(m.type !== type) continue;
      m.progress += val;
      if(m.progress >= m.target){
        m.done = true;
        // rewards instantly
        const r = m.rewards||{};
        if(r.coins) S.coins += r.coins;
        if(r.keys)  S.keys  += r.keys;
        if(r.chests) S.chests += r.chests;
        toast(`–ú–ò–°–°–ò–Ø –ì–û–¢–û–í–ê ‚úÖ +${r.coins||0}‚òÖ${r.keys?(" +"+r.keys+"üîë"):""}${r.chests?(" +"+r.chests+"üéÅ"):""}`);
        // replace mission
        changed = true;
      }
    }
    if(changed){
      // remove done missions and replace with new ones
      S.missions = S.missions.filter(m=>!m.done);
      ensureMissions();
      saveNow();
    }
  }

  // ====== GAME FLOW ======
  function startRun(){
    running = true;
    paused = false;
    menu.style.display = "none";
    hud.style.display = "flex";
    entities.length = 0;

    score = 0;
    combo = 1;
    comboDecay = 0;
    meters = 0;
    runCoins = 0;
    speed = 10;
    z = 0;

    P.lane = 0;
    P.laneX = laneX(0);
    P.y = groundY();
    P.vy = 0;
    P.jump = false;
    P.roll = false;
    P.rollT = 0;
    P.alive = true;
    P.invulnT = 0;
    P.turboT = 0;

    // initial spawns
    for(let i=0;i<8;i++){
      spawnPattern();
      z += 40;
    }
    z = 0;

    S.stats.runs++;
    addMissionProgress("runs", 1);
    saveNow();

    toast("–ü–û–ï–•–ê–õ–ò üöÄ");
    tPrev = performance.now();
    requestAnimationFrame(loop);
  }

  function endRun(reason="–ü—Ä–æ–∏–≥—Ä—ã—à"){
    running = false;
    paused = false;

    // commit loot
    S.coins += runCoins;
    S.stats.coins += runCoins;
    S.stats.meters += Math.floor(meters);

    // highscore
    if(score > S.best){
      S.best = Math.floor(score);
      // bonus chest for new record sometimes
      if(Math.random()<0.40){ S.chests += 1; toast("–†–ï–ö–û–†–î! üéÜ +1 —Å—É–Ω–¥—É–∫"); }
      saveNow();
      showModal("–ù–û–í–´–ô –†–ï–ö–û–†–î üëë", `–°—á—ë—Ç: ${Math.floor(score)}\n–ú–æ–Ω–µ—Ç—ã –∑–∞ –∑–∞–±–µ–≥: ${runCoins}`, {
        rewards: [
          {k:"–°—á—ë—Ç", v:String(Math.floor(score))},
          {k:"–ú–æ–Ω–µ—Ç—ã", v:`${runCoins} ‚òÖ`},
          {k:"–î–∏—Å—Ç–∞–Ω—Ü–∏—è", v:`${Math.floor(meters)} –º`},
        ],
        hint:"–ñ–º–∏ ¬´–ò–≥—Ä–∞—Ç—å¬ª, —á—Ç–æ–±—ã —Å–Ω–æ–≤–∞ –≤–ª–µ—Ç–µ—Ç—å."
      });
    } else {
      saveNow();
      showModal(reason, `–°—á—ë—Ç: ${Math.floor(score)}\n–ú–æ–Ω–µ—Ç—ã –∑–∞ –∑–∞–±–µ–≥: ${runCoins}`, {
        rewards: [
          {k:"–°—á—ë—Ç", v:String(Math.floor(score))},
          {k:"–ú–æ–Ω–µ—Ç—ã", v:`${runCoins} ‚òÖ`},
          {k:"–î–∏—Å—Ç–∞–Ω—Ü–∏—è", v:`${Math.floor(meters)} –º`},
        ],
        hint:"–ü—Ä–æ–∏–≥—Ä—ã—à ‚Äî –∫–æ–≥–¥–∞ –≤–ª–µ—Ç–µ–ª–∞ –≤ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ –±–µ–∑ —â–∏—Ç–∞."
      });
    }

    menu.style.display = "grid";
    hud.style.display = "none";
    renderMenu();
  }

  // ====== INPUT ======
  function laneLeft(){ P.lane = Math.max(-1, P.lane-1); }
  function laneRight(){ P.lane = Math.min(1, P.lane+1); }

  function doJump(){
    if(P.jump) return;
    if(P.roll) return;
    P.vy = -H*0.015;
    P.jump = true;
    S.stats.jumps++;
    addMissionProgress("jumps", 1);
    saveNow();
  }
  function doRoll(){
    if(P.jump) return;
    if(P.roll) return;
    P.roll = true;
    P.rollT = 0.55;
    S.stats.rolls++;
    addMissionProgress("rolls", 1);
    saveNow();
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    toast(paused ? "–ü–ê–£–ó–ê ‚è∏" : "–ü–û–ï–•–ê–õ–ò ‚ñ∂Ô∏è");
    if(!paused){
      tPrev = performance.now();
      requestAnimationFrame(loop);
    }
  }
  btnPause.addEventListener("click", togglePause);

  // board activation
  function activateBoard(){
    const id = S.activeBoard;
    if(id==="Basic"){ toast("Basic ‚Äî –ø—Ä–æ—Å—Ç–æ —Å—Ç–∏–ª—å üòà"); return; }
    const stock = S.boardStock[id]||0;
    if(stock<=0){ toast("–ó–∞—Ä—è–¥–æ–≤ –Ω–µ—Ç üòà"); return; }

    S.boardStock[id] = stock - 1;
    saveNow();

    if(id==="Shield"){
      P.invulnT = Math.max(P.invulnT, 10.0);
      toast("–©–ò–¢ üõ°Ô∏è 10s");
    } else if(id==="Turbo"){
      P.turboT = Math.max(P.turboT, 8.0);
      toast("–¢–£–†–ë–û üöÄ 8s");
    }
  }

  // Keyboard
  addEventListener("keydown", (e)=>{
    if(menu.style.display !== "none"){
      if(e.key==="Enter") startRun();
      return;
    }
    if(e.key==="ArrowLeft") laneLeft();
    if(e.key==="ArrowRight") laneRight();
    if(e.key==="ArrowUp") doJump();
    if(e.key==="ArrowDown") doRoll();
    if(e.key==="p"||e.key==="P") togglePause();
    if(e.key==="b"||e.key==="B") activateBoard();
  });

  // Swipe
  let touchStart = null;
  addEventListener("pointerdown", (e)=>{
    if(menu.style.display !== "none") return;
    touchStart = {x:e.clientX, y:e.clientY, t:performance.now()};
  });
  addEventListener("pointerup", (e)=>{
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const dt = performance.now() - touchStart.t;
    touchStart = null;
    if(dt>500) return;
    if(adx<20 && ady<20) return;

    if(adx>ady){
      if(dx<0) laneLeft(); else laneRight();
    } else {
      if(dy<0) doJump(); else doRoll();
    }
  });

  // ====== LOOP ======
  function loop(tNow){
    if(!running || paused) return;

    const dt = Math.min(0.033, (tNow - tPrev)/1000);
    tPrev = tNow;
    time += dt;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  function update(dt){
    // speed ramp + turbo
    const ramp = 1 + Math.min(0.75, meters/3000);
    const turbo = P.turboT>0 ? 1.55 : 1.0;
    const v = speed * ramp * turbo;

    // meters
    meters += v * dt * 2.2;
    addMissionProgress("meters", v*dt*2.2);

    // score
    score += v * dt * 3.0 + combo*dt*6;
    uiScore.textContent = Math.floor(score);

    // combo decay slowly
    comboDecay += dt;
    if(comboDecay > 3.0){
      combo = Math.max(1, combo-1);
      comboDecay = 0;
      uiCombo.textContent = `x${combo}`;
    }

    // player lane smoothing
    const targetX = laneX(P.lane);
    P.laneX = lerp(P.laneX, targetX, 1 - Math.pow(0.001, dt)); // smooth

    // gravity & jump
    const g = H*0.030;
    if(P.jump){
      P.vy += g*dt;
      P.y += P.vy;
      if(P.y >= groundY()){
        P.y = groundY();
        P.vy = 0;
        P.jump = false;
      }
    } else {
      P.y = groundY();
    }

    // roll
    if(P.roll){
      P.rollT -= dt;
      if(P.rollT<=0){ P.roll=false; }
    }

    // shield/turbo time
    if(P.invulnT>0) P.invulnT -= dt;
    if(P.turboT>0) P.turboT -= dt;

    // spawn as you progress
    const spawnEvery = lerp(34, 26, Math.min(1, meters/2500));
    if(meters - (update.lastSpawn || 0) > spawnEvery){
      update.lastSpawn = meters;
      spawnPattern();
    }

    // update entities moving toward player: using z relative to meters
    const playerZ = meters;
    // collision window around z=playerZ
    for(const e of entities){
      e.dz = e.z - playerZ;
    }

    // collect / collision
    for(const e of entities){
      if(e.kind==="coin" && !e.taken){
        if(Math.abs(e.dz) < 6.0 && e.lane===P.lane){
          // if coin arc, must be in jump range to count height? keep simple: always collect if aligned
          e.taken = true;
          runCoins += 1;
          addMissionProgress("coins", 1);
          uiCoins.textContent = Math.floor(runCoins);
          // combo bump
          combo = Math.min(41, combo+1);
          comboDecay = 0;
          uiCombo.textContent = `x${combo}`;
          // tiny score bonus
          score += 25 * combo;
          // sometimes key
          if(Math.random()<0.03){
            S.keys += 1;
            uiKeys.textContent = Math.floor(S.keys);
            toast("–ö–ª—é—á üîë");
            saveNow();
          }
        }
      }

      if(e.kind==="ob"){
        if(Math.abs(e.dz) < 5.5 && e.lane===P.lane){
          // determine hit by type & player state
          let hit = false;
          if(e.type===OB.TRAIN){
            hit = true; // always hit if in same lane
          } else if(e.type===OB.BARRIER){
            // need jump
            hit = !P.jump;
          } else if(e.type===OB.LOWBAR){
            // need roll
            hit = !P.roll;
          }

          // near miss bonus when barely passed
          if(!hit && e._missed!==true && e.dz < -1.0){
            e._missed = true;
            score += 80 * combo;
            comboDecay = 0;
            toast("NEAR MISS üî•");
          }

          if(hit){
            if(P.invulnT>0){
              // shield absorbs
              P.invulnT = Math.max(0, P.invulnT - 4.0);
              score += 120;
              toast("–©–ò–¢ –°–ü–ê–° üõ°Ô∏è");
              e._broken = true;
            } else {
              P.alive = false;
            }
          }
        }
      }
    }

    // cleanup far entities
    for(let i=entities.length-1;i>=0;i--){
      const e=entities[i];
      if(e.dz < -80) entities.splice(i,1);
      // remove broken obstacles after hit
      if(e._broken) entities.splice(i,1);
    }

    // game over
    uiKeys.textContent = Math.floor(S.keys);
    if(!P.alive){
      endRun("–ë–ê–ú üí•");
    }
  }
  update.lastSpawn = 0;

  function lerp(a,b,t){ return a + (b-a)*t; }

  // ====== DRAW ======
  function draw(){
    // background sky gradient
    ctx.clearRect(0,0,W,H);
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, "rgba(80,210,255,.70)");
    grd.addColorStop(1, "rgba(30,40,140,.90)");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);

    // distant city / mountains
    drawHills();

    // tracks perspective
    drawTracks();

    // entities (sorted by dz far->near)
    const sorted = entities.slice().sort((a,b)=>b.dz - a.dz);
    for(const e of sorted){
      if(e.kind==="coin" && !e.taken) drawCoin(e);
      if(e.kind==="ob") drawObstacle(e);
    }

    // player
    drawPlayer();

    // overlays: shield/turbo
    if(P.invulnT>0){
      drawGlowRing(P.laneX, P.y, 58, "rgba(42,161,255,.38)");
    }
    if(P.turboT>0){
      drawGlowRing(P.laneX, P.y, 70, "rgba(255,122,0,.26)");
    }

    // top HUD values
    uiCoins.textContent = Math.floor(runCoins);
    uiKeys.textContent = Math.floor(S.keys);
  }

  function proj(dz){
    // dz: ahead distance (positive = ahead)
    const depth = clamp(dz / 160, 0, 1);
    const y = lerp(groundY(), horizonY(), depth);
    const scale = lerp(1.0, 0.12, depth);
    return {y, scale, depth};
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function drawHills(){
    const hy = horizonY();
    // sun
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(255,204,77,.9)";
    ctx.beginPath();
    ctx.arc(W*0.78, H*0.20, 70*DPR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // mountains
    ctx.fillStyle = "rgba(10,30,80,.35)";
    ctx.beginPath();
    ctx.moveTo(0, hy+70*DPR);
    ctx.quadraticCurveTo(W*0.25, hy-40*DPR, W*0.48, hy+60*DPR);
    ctx.quadraticCurveTo(W*0.68, hy+110*DPR, W, hy+40*DPR);
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();

    // buildings silhouettes
    ctx.fillStyle = "rgba(0,0,0,.18)";
    for(let i=0;i<14;i++){
      const x = (i/14)*W + Math.sin(i*2.1+time*0.2)*8*DPR;
      const w = rnd(24, 56)*DPR;
      const h = rnd(40, 120)*DPR;
      ctx.fillRect(x, hy+40*DPR-h, w, h);
    }
  }
  function rnd(a,b){ return Math.random()*(b-a)+a; }

  function drawTracks(){
    const gy = groundY();
    const hy = horizonY();

    // ground
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.beginPath();
    ctx.moveTo(0, gy+60*DPR);
    ctx.lineTo(W, gy+60*DPR);
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();

    // rails: 3 lanes, 4 rails between
    for(let i=-2;i<=2;i++){
      const x0 = W*0.5 + i*(W*0.09);
      // near width
      const wNear = 10*DPR;
      const wFar  = 2*DPR;
      ctx.strokeStyle = "rgba(255,255,255,.55)";
      ctx.lineWidth = lerp(wNear, wFar, 0.95);
      ctx.beginPath();
      ctx.moveTo(x0 - wNear*0.5, gy);
      ctx.lineTo(lerp(x0, W*0.5 + i*(W*0.02), 0.95), hy);
      ctx.stroke();

      // dark rail shadow
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = lerp(wNear*0.65, wFar*0.65, 0.95);
      ctx.beginPath();
      ctx.moveTo(x0 + wNear*0.25, gy);
      ctx.lineTo(lerp(x0 + wNear*0.25, W*0.5 + i*(W*0.02), 0.95), hy);
      ctx.stroke();
    }

    // sleepers (ties)
    for(let k=0;k<26;k++){
      const dz = k*10 + (meters*0.6)%10;
      const p = proj(dz);
      const y = p.y;
      const w = lerp(W*0.72, W*0.20, p.depth);
      const h = lerp(10*DPR, 2*DPR, p.depth);
      ctx.fillStyle = "rgba(120,60,120,.35)";
      ctx.fillRect(W*0.5 - w*0.5, y, w, h);
    }

    // lane separators glow
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(42,161,255,.55)";
    ctx.lineWidth = 2*DPR;
    for(let i=-1;i<=1;i++){
      const xNear = laneX(i);
      const xFar  = lerp(xNear, W*0.5 + i*(W*0.02), 0.92);
      ctx.beginPath();
      ctx.moveTo(xNear, gy);
      ctx.lineTo(xFar, hy);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCoin(e){
    const p = proj(e.dz);
    const x = laneX(e.lane);
    const y = p.y - lerp(40*DPR, 2*DPR, p.depth) - (e.arc!=null ? Math.sin(e.arc*0.6)*12*DPR*p.scale : 0);
    const r = lerp(18*DPR, 4*DPR, p.depth);

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#ffcc4d";
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,.20)";
    ctx.beginPath(); ctx.arc(x+r*0.12, y+r*0.10, r*0.85, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.50)";
    ctx.beginPath(); ctx.arc(x-r*0.30, y-r*0.30, r*0.35, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawObstacle(e){
    const p = proj(e.dz);
    const x = laneX(e.lane);
    const y = p.y;
    const w = lerp(W*0.22, W*0.06, p.depth);
    const hBase = lerp(120*DPR, 18*DPR, p.depth);

    ctx.save();
    // train is huge
    if(e.type===OB.TRAIN){
      const wT = w*1.25;
      const hT = hBase*1.05;
      ctx.fillStyle = "rgba(255,255,255,.14)";
      roundRect(x-wT*0.5, y-hT, wT, hT, 10*p.scale);
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,.20)";
      roundRect(x-wT*0.5+6*p.scale, y-hT+8*p.scale, wT-12*p.scale, hT*0.45, 10*p.scale);
      ctx.fill();

      ctx.fillStyle = "rgba(42,161,255,.35)";
      roundRect(x-wT*0.5+10*p.scale, y-hT+12*p.scale, wT-20*p.scale, hT*0.36, 10*p.scale);
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(x-wT*0.5, y-hT*0.18, wT, hT*0.18);
    }

    if(e.type===OB.BARRIER){
      const wB = w*0.95;
      const hB = hBase*0.72;
      ctx.fillStyle = "rgba(255,77,115,.85)";
      roundRect(x-wB*0.5, y-hB, wB, hB, 12*p.scale);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      for(let i=0;i<4;i++){
        ctx.fillRect(x-wB*0.5 + (i/4)*wB, y-hB, wB*0.12, hB);
      }
      // feet
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(x-wB*0.55, y-hB*0.06, wB*0.12, hB*0.06);
      ctx.fillRect(x+wB*0.43, y-hB*0.06, wB*0.12, hB*0.06);
    }

    if(e.type===OB.LOWBAR){
      const wL = w*1.05;
      const hL = hBase*0.42;
      ctx.fillStyle = "rgba(255,204,77,.88)";
      roundRect(x-wL*0.5, y-hL, wL, hL, 12*p.scale);
      ctx.fill();
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(x-wL*0.5, y-hL*0.12, wL, hL*0.12);
      ctx.fillStyle = "rgba(0,0,0,.15)";
      ctx.fillRect(x-wL*0.5, y-hL*0.70, wL, hL*0.08);
    }
    ctx.restore();
  }

  function drawPlayer(){
    const x = P.laneX;
    const y = P.y;
    const ch = Characters.find(a=>a.id===S.activeChar) || Characters[0];
    const col = ch.color || "#fff";

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.ellipse(x, groundY()+8*DPR, 34*DPR, 12*DPR, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body size depends on roll
    const bodyH = P.roll ? 52*DPR : 80*DPR;
    const bodyW = 40*DPR;

    // board under feet (purely visual)
    const b = Boards.find(bb=>bb.id===S.activeBoard) || Boards[0];
    const boardY = groundY()+2*DPR;
    ctx.save();
    ctx.globalAlpha = (P.turboT>0||P.invulnT>0)?0.95:0.85;
    ctx.fillStyle = b.color || "#33e28a";
    roundRect(x-42*DPR, boardY-12*DPR, 84*DPR, 18*DPR, 10*DPR);
    ctx.fill();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    roundRect(x-30*DPR, boardY-8*DPR, 60*DPR, 6*DPR, 6*DPR);
    ctx.fill();
    ctx.restore();

    // player
    ctx.save();
    ctx.fillStyle = col;

    // torso
    roundRect(x-bodyW*0.5, y-bodyH, bodyW, bodyH, 16*DPR);
    ctx.fill();

    // head
    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.beginPath(); ctx.arc(x, y-bodyH-18*DPR, 18*DPR, 0, Math.PI*2); ctx.fill();

    // hoodie stripe
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(x-bodyW*0.5, y-bodyH*0.60, bodyW, 8*DPR);

    // glow outline when invuln
    if(P.invulnT>0){
      ctx.strokeStyle = "rgba(42,161,255,.75)";
      ctx.lineWidth = 4*DPR;
      roundRect(x-bodyW*0.5, y-bodyH, bodyW, bodyH, 16*DPR);
      ctx.stroke();
    }
    ctx.restore();

    // warnings (simple HUD inside canvas)
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(0,0,0,.30)";
    roundRect(W*0.5-120*DPR, horizonY()-20*DPR, 240*DPR, 34*DPR, 14*DPR);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.90)";
    ctx.font = `${Math.floor(14*DPR)}px ui-rounded, system-ui`;
    const status = (P.invulnT>0) ? `–©–ò–¢: ${P.invulnT.toFixed(1)}s` :
                   (P.turboT>0) ? `–¢–£–†–ë–û: ${P.turboT.toFixed(1)}s` :
                   `–î–û–°–ö–ê: ${S.activeBoard} (B)`;
    ctx.fillText(status, W*0.5-110*DPR, horizonY()+2*DPR);
    ctx.restore();
  }

  function drawGlowRing(x,y,r,color){
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = color;
    ctx.lineWidth = 10*DPR;
    ctx.beginPath();
    ctx.arc(x, y-40*DPR, r*DPR, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.max(2, r);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // ====== MENU BUTTONS ======
  btnPlay.addEventListener("click", startRun);

  // ====== INIT MENU ======
  ensureMissions();
  renderMenu();
  hud.style.display = "none";

  // ====== PAUSE ON VISIBILITY ======
  document.addEventListener("visibilitychange", ()=>{
    if(running && !paused) togglePause();
  });

  // ====== EXTRA: update missions from save baseline ======
  // (simple mirror for ui keys in-run)
  uiKeys.textContent = Math.floor(S.keys);
  uiCoins.textContent = "0";

  // ====== helper for lerp used in spawn ======
  function lerp(a,b,t){ return a + (b-a)*t; }

})();
</script>
</body>
</html>
